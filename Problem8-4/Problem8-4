/*
* 频率域图像增强
* 写个同态滤波
*/

#include<iostream>
#include<opencv2/opencv.hpp>
#include<fstream>
using namespace std;


cv::Mat readBinary8bitImage(
	string filepath, int rowNum, int colNum);
cv::Mat FFT_Shift(cv::Mat complexI);

int main() {
	string filepath1 = "../../Chap8/data/Landsat8_OLI_b2.dat";
	cv::Mat OriImage = readBinary8bitImage(filepath1, 397, 395);
	OriImage.convertTo(OriImage, CV_32F);
	cv::imshow("oriImage", OriImage/255.0);

	cv::Mat logImage(OriImage.size(), CV_32F);
	for (int i = 0; i < OriImage.rows; i++) {
		for (int j = 0; j < OriImage.cols; j++) {
			logImage.at<float>(i, j) =  OriImage.at<float>(i, j)+;
		}
	}
	
	cv::Mat padded;
	int m = cv::getOptimalDFTSize(logImage.rows);
	int n = cv::getOptimalDFTSize(logImage.cols);
	cv::copyMakeBorder(logImage, padded,
		0, m - logImage.rows,
		0, n - logImage.cols,
		CV_HAL_BORDER_CONSTANT,
		cv::Scalar::all(0));
	cv::Mat planes[] = {
			cv::Mat_<float>(padded),
			cv::Mat::zeros(padded.size(),CV_32F)
	};
	cv::Mat complexI;
	// 把上面的实部和虚部组合成一个双通道图像
	cv::merge(planes, 2, complexI);
	cv::dft(complexI, complexI); // 调用fft算法
	complexI = FFT_Shift(complexI);
	double n1 = (complexI.rows-1) / 2.0;
	double n2 = (complexI.cols-1) / 2.0;

	//同态滤波器 本质是压缩低频增加高频
	for (int i = 0; i < complexI.rows; i++) {
		for (int j = 0; j < complexI.cols; j++) {
			//double d = sqrt(
			//	(i - n1) * (i - n1) + (j - n2) * (j - n2));
			///*double d0 = 35.0;
			//double c = 1.0;
			//double rh = 2;
			//double rl = 0.25;
			//double h =
			//	(rh - rl) * (1 - exp(-1 * c * (d * d / (d0 *d0)))) + rl;*/
			//if (d > 35) {
			//	complexI.at<cv::Vec2f>(i, j)[0] *= 2;
			//	complexI.at<cv::Vec2f>(i, j)[1] *= 2;
			//}
		}
	}
	complexI = FFT_Shift(complexI);
	cv::Mat ifft;
	cv::idft(complexI, ifft, cv::DFT_REAL_OUTPUT);
	for (int i = 0; i < ifft.rows; i++) {
		for (int j = 0; j < ifft.cols; j++) {
			
		}
	}
	cv::normalize(ifft, ifft, 0, 1, cv::NORM_MINMAX);
	cv::imshow("ifft", ifft);
	cv::waitKey(0);

}

cv::Mat readBinary8bitImage(
	string filepath, int rowNum, int colNum) {

	cv::Mat image(rowNum, colNum, CV_8UC1);
	int num = 0;
	int value;
	ifstream readDatFstream(filepath, ios::binary | ios::in);
	while (readDatFstream.read(
		(char*)&value, 1
	)) {
		int row = (num / colNum);
		int col = num % colNum;
		image.at<uchar>(row, col) = value;
		num++;
	}
	return image;
}

cv::Mat FFT_Shift(cv::Mat complexI) {
	cv::Mat ReComplexI = complexI(cv::Rect(0, 0, complexI.cols & -2, complexI.rows & -2));
	int cx = ReComplexI.cols / 2;
	int cy = ReComplexI.rows / 2;
	cv::Mat q0(ReComplexI, cv::Rect(0, 0, cx, cy));       //左上角图像划定ROI区域
	cv::Mat q1(ReComplexI, cv::Rect(cx, 0, cx, cy));      //右上角图像
	cv::Mat q2(ReComplexI, cv::Rect(0, cy, cx, cy));      //左下角图像
	cv::Mat q3(ReComplexI, cv::Rect(cx, cy, cx, cy));     //右下角图像

	//变换左上角和右下角象限
	cv::Mat tmp;
	q0.copyTo(tmp);
	q3.copyTo(q0);
	tmp.copyTo(q3);

	//变换右上角和左下角象限
	q1.copyTo(tmp);
	q2.copyTo(q1);
	tmp.copyTo(q2);
	return ReComplexI;
}
